# -*- coding: utf-8 -*-
"""colab files.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IhYAIAHSFS7oZVRHnZbNULh-0gclu_ZT
"""

import random

def roll_die():
    return random.randint(1, 6)

def simulate_rolls(target, rolls):
    target_count = 0
    roll_counts = [0] * 6

    for _ in range(rolls):
        result = roll_die()
        roll_counts[result - 1] += 1
        if result == target:
            target_count += 1

    probability = target_count / rolls

    print(f"Probability of rolling a {target}: {probability:.2f}")
    print("Roll counts for each number:")
    for i in range(1, 7):
        print(f"  {i}: {roll_counts[i - 1]}")

target_number = int(input("Enter the target number (1 to 6): "))
total_rolls = int(input("Enter the number of rolls: "))

simulate_rolls(target=target_number, rolls=total_rolls)

import random

def calculate_conditional_probability(num_rolls):
    """Calculate the probability that the sum is 7 given that one die shows 4."""
    count_A_and_B = 0  # Count of (sum is 7 and one die shows 4)
    count_B = 0        # Count of (one die shows 4)

    for _ in range(num_rolls):
        die1 = random.randint(1, 6)
        die2 = random.randint(1, 6)

        # Check if at least one die is 4
        if die1 == 4 or die2 == 4:
            count_B += 1
            # Check if the sum is 7
            if die1 + die2 == 7:
                count_A_and_B += 1

    # Calculate conditional probability P(A|B)
    return count_A_and_B / count_B if count_B > 0 else 0

def main():
    try:
        num_rolls = int(input("Enter the number of rolls to simulate: "))
        if num_rolls <= 0:
            print("Please enter a positive integer for the number of rolls.")
            return
        conditional_prob = calculate_conditional_probability(num_rolls)
        print(f"The conditional probability P(A|B) is: {conditional_prob:.4f}")
    except ValueError:
        print("Invalid input. Please enter an integer.")

if __name__ == "__main__":
    main()

import numpy as np

def check_independence(A, B):
    # Calculate probabilities
    P_A = np.mean(A)  # Probability of A
    P_B = np.mean(B)  # Probability of B
    P_A_and_B = np.mean(A * B)  # Joint probability of A and B

    # Check independence condition
    independence_condition = np.isclose(P_A_and_B, P_A * P_B)

    # Display results
    print(f"P(A): {P_A:.4f}")
    print(f"P(B): {P_B:.4f}")
    print(f"P(A and B): {P_A_and_B:.4f}")
    print(f"P(A) * P(B): {P_A * P_B:.4f}")
    print(f"Are A and B independent? {'Yes' if independence_condition else 'No'}")

def main():
    # In Google Colab, we suggest hardcoding inputs for testing or providing clear instructions for manual entry.
    n_samples = int(input("Enter the number of samples: "))

    # Ensure to guide the user properly
    print("Enter values for event A (space-separated, 0s and 1s):")
    A = np.array(list(map(int, input().split())))
    print("Enter values for event B (space-separated, 0s and 1s):")
    B = np.array(list(map(int, input().split())))

    # Ensure input lengths match
    if len(A) != n_samples or len(B) != n_samples:
        print("Error: The number of samples does not match the input length.")
        return

    check_independence(A, B)

# Corrected main entry point
if __name__ == "__main__":
    main()

import numpy as np
import matplotlib.pyplot as plt

# Define a discrete random variable (Die Roll)
X = np.arange(1, 7)
P_X = np.ones(6) / 6  # Equal probability for each face of a die

# Calculate expected value (mean) and variance
expected_value = np.sum(X * P_X)
variance = np.sum((X - expected_value)**2 * P_X)
# Print results
print("Expected Value:", expected_value)
print("Variance:", variance)

# Plotting the PMF
plt.bar(X, P_X, color='blue')
plt.title('Probability Mass Function (Die Roll)')
plt.xlabel('Outcome')
plt.ylabel('Probability')
plt.show()